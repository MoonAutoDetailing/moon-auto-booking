async function resolveQuote() {
  if (!selectedVehicleSize || !selectedServiceType) return;

  const { data, error } = await supabase
    .from("service_pricing")
    .select("duration_minutes, price_cents")
    .eq("vehicle_size", selectedVehicleSize)
    .eq("service_type", selectedServiceType)
    .eq("is_active", true)
    .maybeSingle();

  if (error) {
    console.error("Service pricing lookup failed:", error);
    return;
  }

  if (!data) {
    console.warn(
      "No pricing configured for:",
      selectedVehicleSize,
      selectedServiceType
    );
    return;
  }

  resolvedDurationMinutes = data.duration_minutes;
  resolvedPriceCents = data.price_cents;

  durationText.textContent = formatDuration(resolvedDurationMinutes);
  priceText.textContent = formatPrice(resolvedPriceCents);

  quoteBox.style.display = "block";

  tryUnlockCalendar();
}

function tryUnlockCalendar() {
  const ready =
    selectedVehicleSize &&
    selectedServiceType &&
    Number.isInteger(resolvedDurationMinutes);

  if (!ready) {
    calendarSection.style.display = "none";
    return;
  }

  calendarSection.style.display = "block";

  // Hook into your EXISTING calendar logic here
  // Example:
  // updateCalendarWithDuration(resolvedDurationMinutes);
}


async function fetchBookingsForDay(dateISO) {
  const dayStart = new Date(dateISO);
  dayStart.setHours(0, 0, 0, 0);

  const dayEnd = new Date(dateISO);
  dayEnd.setHours(23, 59, 59, 999);

  const { data, error } = await supabase
    .from("bookings")
    .select("start_time, end_time")
    .gte("start_time", dayStart.toISOString())
    .lte("start_time", dayEnd.toISOString());

  if (error) {
    console.error("Failed to fetch bookings:", error);
    return [];
  }

  return data;
}


function generateTimeSlots(dateISO) {
  const slots = [];

  const startHour = 8;
  const endHour = 18;
  const intervalMinutes = 30;

  const baseDate = new Date(dateISO);
  baseDate.setHours(0, 0, 0, 0);

  for (let hour = startHour; hour < endHour; hour++) {
    for (let min = 0; min < 60; min += intervalMinutes) {
      const slot = new Date(baseDate);
      slot.setHours(hour, min, 0, 0);
      slots.push(slot);
    }
  }

  return slots;
}


                                    function isSlotAvailable(slotStart, durationMinutes, bookings) {
  const slotEnd = new Date(slotStart);
  slotEnd.setMinutes(slotEnd.getMinutes() + durationMinutes);

  for (const booking of bookings) {
    const bookingStart = new Date(booking.start_time);
    const bookingEnd = new Date(booking.end_time);

    const overlaps =
      slotStart < bookingEnd && slotEnd > bookingStart;

    if (overlaps) return false;
  }

  return true;
}


    async function buildAvailabilityForDate(dateISO) {
  if (!Number.isInteger(resolvedDurationMinutes)) {
    console.warn("Duration not resolved — calendar locked");
    return;
  }

  const bookings = await fetchBookingsForDay(dateISO);
  const slots = generateTimeSlots(dateISO);

  const availability = slots.map(slot => ({
    start: slot,
    available: isSlotAvailable(
      slot,
      resolvedDurationMinutes,
      bookings
    )
  }));

  renderCalendar(availability);
}

    function renderCalendar(availability) {
  availability.forEach(slot => {
    if (slot.available) {
      // render clickable slot
    } else {
      // render blocked/disabled slot
    }
  });
}

    function handleSlotClick(slotStart) {
  const start = new Date(slotStart);
  const end = new Date(start);
  end.setMinutes(end.getMinutes() + resolvedDurationMinutes);

  // Store these for booking insert (unchanged)
  selectedStartTime = start.toISOString();
  selectedEndTime = end.toISOString();
}

    const uiState = {
  quoteStatus: "idle",        // idle | loading | ready | error
  calendarStatus: "locked",   // locked | loading | ready | error
};


    <section id="calendarSection" style="display:none;">
  <div id="calendarLoading" style="display:none;">
    Loading availability…
  </div>

  <div id="calendarError" style="display:none;">
    Unable to load availability. Please try again.
  </div>

  <div id="calendar"></div>
</section>


    async function resolveQuote() {
  if (!selectedVehicleSize || !selectedServiceType) return;

  uiState.quoteStatus = "loading";
  quoteBox.style.display = "none";
  calendarSection.style.display = "none";

  const { data, error } = await supabase
    .from("service_pricing")
    .select("duration_minutes, price_cents")
    .eq("vehicle_size", selectedVehicleSize)
    .eq("service_type", selectedServiceType)
    .eq("is_active", true)
    .maybeSingle();

  if (error || !data) {
    uiState.quoteStatus = "error";
    console.error("Quote resolution failed", error);
    return;
  }

  resolvedDurationMinutes = data.duration_minutes;
  resolvedPriceCents = data.price_cents;

  durationText.textContent = formatDuration(resolvedDurationMinutes);
  priceText.textContent = formatPrice(resolvedPriceCents);

  quoteBox.style.display = "block";
  uiState.quoteStatus = "ready";

  tryUnlockCalendar();
}


    function tryUnlockCalendar() {
  const ready =
    uiState.quoteStatus === "ready" &&
    Number.isInteger(resolvedDurationMinutes);

  if (!ready) {
    uiState.calendarStatus = "locked";
    calendarSection.style.display = "none";
    return;
  }

  calendarSection.style.display = "block";
  uiState.calendarStatus = "loading";

  loadCalendarForSelectedDate();
}


    async function loadCalendarForSelectedDate() {
  const loadingEl = document.getElementById("calendarLoading");
  const errorEl = document.getElementById("calendarError");

  loadingEl.style.display = "block";
  errorEl.style.display = "none";

  try {
    await buildAvailabilityForDate(selectedDateISO);
    uiState.calendarStatus = "ready";
  } catch (err) {
    console.error("Calendar availability failed", err);
    uiState.calendarStatus = "error";
    errorEl.style.display = "block";
  } finally {
    loadingEl.style.display = "none";
  }
}


    function handleSlotClick(slotStart) {
  if (uiState.calendarStatus !== "ready") return;

  const start = new Date(slotStart);
  const end = new Date(start);
  end.setMinutes(end.getMinutes() + resolvedDurationMinutes);

  selectedStartTime = start.toISOString();
  selectedEndTime = end.toISOString();
}


    function resetDownstreamState() {
  resolvedDurationMinutes = null;
  resolvedPriceCents = null;

  uiState.quoteStatus = "idle";
  uiState.calendarStatus = "locked";

  quoteBox.style.display = "none";
  calendarSection.style.display = "none";
}

    effectiveDurationMinutes =
  baseServiceDurationMinutes
+ travelPaddingMinutes


    let baseDurationMinutes = null;        // from DB
let travelPaddingMinutes = 0;          // dynamic later
let effectiveDurationMinutes = null;   // what calendar uses


    baseDurationMinutes = data.duration_minutes;
resolvedPriceCents = data.price_cents;

// travel padding will be computed later
travelPaddingMinutes = 0;

effectiveDurationMinutes =
  baseDurationMinutes + travelPaddingMinutes;

durationText.textContent =
  formatDuration(baseDurationMinutes); // IMPORTANT: show base duration only

priceText.textContent = formatPrice(resolvedPriceCents);

quoteBox.style.display = "block";
uiState.quoteStatus = "ready";

tryUnlockCalendar();

    Number.isInteger(effectiveDurationMinutes)

    function tryUnlockCalendar() {
  const ready =
    uiState.quoteStatus === "ready" &&
    Number.isInteger(effectiveDurationMinutes);

  if (!ready) {
    uiState.calendarStatus = "locked";
    calendarSection.style.display = "none";
    return;
  }

  calendarSection.style.display = "block";
  uiState.calendarStatus = "loading";

  loadCalendarForSelectedDate();
}


    function isSlotAvailable(slotStart, bookings) {
  const slotEnd = new Date(slotStart);
  slotEnd.setMinutes(
    slotEnd.getMinutes() + effectiveDurationMinutes
  );

  for (const booking of bookings) {
    const bookingStart = new Date(booking.start_time);
    const bookingEnd = new Date(booking.end_time);

    if (slotStart < bookingEnd && slotEnd > bookingStart) {
      return false;
    }
  }

  return true;
}


      function handleSlotClick(slotStart) {
  if (uiState.calendarStatus !== "ready") return;

  const start = new Date(slotStart);
  const end = new Date(start);
  end.setMinutes(
    end.getMinutes() + effectiveDurationMinutes
  );

  selectedStartTime = start.toISOString();
  selectedEndTime = end.toISOString();
}

      async function calculateTravelPadding(customerAddress) {
  // later:
  // - call Google Distance Matrix
  // - compute minutes
  // - round up to buffer rules
  // return integer minutes
}

      travelPaddingMinutes = await calculateTravelPadding(address);
effectiveDurationMinutes =
  baseDurationMinutes + travelPaddingMinutes;

tryUnlockCalendar();


      .from("bookings")
.select("start_time, end_time")
.eq("status", "confirmed")
...


      async function fetchBookingsForDay(dateISO) {
  const dayStart = new Date(dateISO);
  dayStart.setHours(0, 0, 0, 0);

  const dayEnd = new Date(dateISO);
  dayEnd.setHours(23, 59, 59, 999);

  const { data, error } = await supabase
    .from("bookings")
    .select("scheduled_start, scheduled_end")
    .eq("status", "confirmed") // if applicable
    .gte("scheduled_start", dayStart.toISOString())
    .lte("scheduled_start", dayEnd.toISOString());

  if (error) {
    console.error("Failed to fetch bookings:", error);
    return [];
  }

  return data;
}


      function isSlotAvailable(slotStart, bookings) {
  const slotEnd = new Date(slotStart);
  slotEnd.setMinutes(
    slotEnd.getMinutes() + effectiveDurationMinutes
  );

  for (const booking of bookings) {
    const bookingStart = new Date(booking.scheduled_start);
    const bookingEnd = new Date(booking.scheduled_end);

    if (slotStart < bookingEnd && slotEnd > bookingStart) {
      return false;
    }
  }

  return true;
}


      if (error?.code === "23P01") {
  // Show user: "That time was just booked. Please select another slot."
}
